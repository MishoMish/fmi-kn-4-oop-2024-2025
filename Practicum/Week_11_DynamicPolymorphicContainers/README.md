# Динамични рекурсивни( и хетерогенни) контейнери

## Какво знаем до момента?
Запознали сме се с концепцията за наследяване и приложението на ***динамичен полиморфизъм***. (някой би ли припомнил какво представлява това?)

## Продължаваме с ...

- ***чисто виртуални методи*** - *чисто виртуален* наричаме такъв метод от базов( родителски) клас, за който липсва реализация. Това би могло да е по различни причини, като най-популярната е именно желанието всеки *наследник* да си дефинира собствено поведение.
```cpp
class Parent
{
public:
    virtual void doSomething() const = 0;
};

class Child : public Parent
{
public:
    void doSomething() const override
    {
        std::cout << "pure virtual method is defined\n";
    }
};
```
***Проблем*** - при наличие на *чисто виртуален метод* обект от съответния клас не може да се инстанцира. Поради тази причина при избор да работим с такива методи ние се съгласяваме да "ползваме" директно само наследници(при това такива, които са реализирали съответните методи).

- ***абстрактен клас*** - *абстрактен* наричаме всеки клас, който съдържа чисто виртуален метод.

- ***интерфейс*** - клас, който съдържа единствено чисто виртуални методи. Препоръчва се употребата на такива, понеже по този начин програмистът единствено трябва да се погрижи за желаното поведение и функционалност, без да "наследените" от родителя неща(например член-данни, невиртуални методи и т.н.).


## Resource Acquisition Is Initialization(RAII)
Накратко: ресурсите, използвани от даден клас, са си негова собственост и той отговаря за тяхното управление(заделяне, обработка и освобождаване).

***Въпрос:*** Спазен ли е този принцип с примера за фигурите от предния път?

*Решение*: Дефиниране на *(чисто)виртуален метод*, който е прието да се именува ***clone***.
```cpp
class Parent
{
public:
    virtual Parent* clone() const
    {
        return new Parent(*this);
    }
};

class Child : public Parent
{
public:
    Child* clone() const override
    {
        return new Child(*this);
    }
};
```

## Factory метод
```cpp
class Button
{
public:
    virtual void click() const = 0;
    virtual ~Button() = default;
};

class WindowsButton : public Button
{
public:
    void click() const override
    {
        std::cout << "WindowsButton clicked\n";
    }
};

class MacButton : public Button
{
public:
    void click() const override
    {
        std::cout << "MacButton clicked\n";
    }
};

class LinuxButton : public Button
{
public:
    void click() const override
    {
        std::cout << "LinuxButton clicked\n";
    }
};

enum OS {WINDOWS, MAC, LINUX, UNKNOWN};

class ButtonFactory
{
public:
    Button* createButton(OS os)
    {
        if (os == WINDOWS)
            return new WindowsButton();
        else if (os == MAC)
            return new MacButton();
        else if (os == LINUX)
            return new LinuxButton();
        
        return nullptr;
    }
};
```

# Задачи за упражнение

*Задача 1.* 
- Да се реализира абстрактен базов клас *SimpleExpression*, описващ прост математически израз. Нека класът съдържа метод getValue, който да връща стойността на израза, и метод за принтиране в поток.
- Да се дефинира наследник *Constant*, който е "опаковка" на константа от тип double. Константа се построява чрез нейната стойност.
- Да се дефинира клас Max, който представя по-голямата от стойностотите на точно два израза(произволни!). Подават се при построяване на обекта.
- Да се дефинира клас Product, който представлява произведение на произволен брой произволни изрази(аааайде може и да се ползва std::vector). Да се добави и метод за добавяне на израз към произведението. Да се осигури възможност за обикаляне на множителите на чрез итератор.

