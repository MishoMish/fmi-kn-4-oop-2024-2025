# Задачи 



### Задача Vector:
Имплементирайте клас `Vector`. `Vector` представлява динамично заделен масив от *цели числа*, който сам управлява паметта си.<br>
Искаме обекти от тип `Vector` да могат да се създават по следния начин:
```
Vector(); // размер 16
Vector(size); // размер = size
Vector(size, val); // размер = size, и стойностите на елементите в масива = val
Vector(Vector&);
```

Да се имплементират следните методи: 
- `resize(size_t N)` - метод за преоразмеряване на контейнера, където N е избрана от вас стойност за преоразмеряване. Метода се използва, когато искаме да добавим елемент в контейнера, но той вече е пълен
- `clear()` - метод за изчистване на съдържанието на вектора
- `аt(size_t x)` - връща елемент на позиция x. Типа трябва да е такъв, че да имаме възможност да променяме елемента извън класа
- `pushBack(int)` - метод за добавяне на елемент в края на vector-а
- `empty()` - връща дали контейнера е празен
- `size()` - връща броя елементи във vector-а
- Имплементирайте деструктор, който да освобождава заделената памет.

*Обърнете внимание кои методи трябва да бъдат `private` и кои - `public`, къде трябва да има константи и референции.*   

Не искаме следното поведение:
```
vector v = 5; //да създава вектор с 5 елемента;
```

### Допълнение 
Модифицирайте класа, така че да може да съдържа произволен тип данни

---

### Задача 2
Използвайки `Задача 1` и `Допълнението към нея` напишете клас String. Искаме той да може да се създава по следните начини:

```
String s;
String s("abcds");
String s = "abcds";
```
Имплементирайте и следните методи:
- `size()` - връща броя символи в низа
- `print()` - принтира низа в конзолата
- `empty()` - връща дали стринга е празен
- `substring(size_t pos, size_t len)` - връща `String`, който е подниз на текущия обект с начало pos и дължина len 
- `append(подходящ тип)` - Долепя подадения низ към текущия

*Упътване: Можете да използвате Vector-a, който сте написали*

Възможно ли е да напишем метода `подходящ-тип getCString()`, така че следния код да работи:
```
int main(){
    String s("abc");
    cout<<s.getCString()<<endl;
}
```

Интересува ни можем ли да го направим така, че данните да са защитени и в същото време да имаме достъп до тях?


---

### Задача 3
Имплементирай клас Matrix, представящ матрица. Искаме тази матрица да не променя размера си по време на изпълнение и да бъде указван в конструктора, когато не копираме от друга матрица. При създаване имаме следните аргументи:
- n - брой редове
- m - брой стълбове
- k - начална стойност на всички клетки

Искаме да можем да създаваме матрица по следните начини:
```
Matrix(n) - квадратна единична матрица с брой редове и стълбове = `n`
Matrix(n, m) - правоъгълна нулева матрица с `n` реда и `m` стълба
Matrix(n, m, k) - правоъгълна матрица с `n` реда и `m` стълба и стойност на клетките = `k`
Matrix(M) - матрица копие на M

```
Имплементирайте следните методи:
- isSquare() - проверява дали матрицата е квадратна
- isIdentity() - проверява дали матрицата е единична 
За следните операции оригиналната матрица и аргумента не трябва да се променят:
- add() - събира 2 матрици 
- subtract() - изважда матрицата аргумент от текущата
- canMultiply() - връща дали матрицата аргумент може да бъде умножена по текущата
- multiply() - умножава две матрици и връща нова
- multiply() - умножава матрица със число
- transpose() - транспонира текущата матрица и връща нова
- isOrtogonal() - връща дали матрица е ортогонална

Погрижете се за жизнения цикъл на обекта.

