# Второ контролно по ООП, КН, 2023/24

### [10 т.] Абстрактен клас `MathExpression`

Да се реализира **абстрактен базов клас** `MathExpression`, описващ **математически израз**, чиято стойност е от тип `double`.

Класът да съдържа следните методи:

- `double value()` — връща числовата стойност на израза;
- `void print(std::ostream& os)` — извежда текстовото представяне на израза в подадения поток.

---

### [5 т.] Клас `Constant`

Да се дефинира клас `Constant`, който представя **константа от тип `double`**.

- Стойността на константата да се задава при конструиране на обекта.
- Да реализира методите от `MathExpression`.

---

### [15 т.] Клас `Min`

Да се дефинира клас `Min`, който представя **по-малката стойност измежду точно два израза** от произволен тип (`MathExpression`).

- Двата израза се задават при конструиране на обекта.
- Да реализира методите от `MathExpression`.

---

### [25 т.] Клас `Sum`

Да се дефинира клас `Sum`, който представя **сумата на произволен брой изрази** от произволен тип (`MathExpression`).

- Да се реализира метод `addExpression`, който добавя нов израз към сумата.
- Да реализира методите от `MathExpression`.

---

### [25 т.] Управление на ресурси и специални функции

Ако и където е нужно, да се реализират:

- подходящи **конструктори** и **деструктори**;
- **оператори за присвояване**;
- **виртуални конструктори** (например метод `clone()`).

---

### [20 т.] Итератор за `Sum`

Класът `Sum` да поддържа **итератор**, чрез който може да се обхождат всички елементи на сумата (например чрез `begin()` и `end()` методи).

---

## Пример

Нека обектът `expr` представя следната структура:

```

Sum
├─ Min
│ ├─ Const(1)
│ └─ Sum
│ ├─ Const(2)
│ └─ Const(1)
├─ Sum
│ ├─ Const(3)
│ ├─ Const(4)
│ └─ Const(5)
└─ Const(10)

```

Методът print на expr да извежда в поток следното представяне на израза:

```c++
sum(min(1,sum(1, 2)),sum(3,4,5),10)
```

Съответно, медодът value на expr да дава числото _23_.

---

# Опит за пресъздаване на Второ контролно по ООП, КН, 2022/23

### [10 т.] Абстрактен клас `Node`

Да се реализира абстрактен базов клас `Node`, представящ **елемент във файлова система**, който може да бъде както текстов документ, така и папка.

Класът да съдържа:

- име (`std::string name`);
- тип (`enum types { TEXT_DOCUMENT, FOLDER }`);
- виртуален метод `void ListContents() const` — извежда съдържанието;
- виртуален метод `Node* copy(const Node& other)` — виртуален конструктор (виртуално копиране);
- подходящи деструктор и конструктор.

---

### [10 т.] Клас `TextDocument`

Да се дефинира клас `TextDocument`, наследяващ `Node`, който представлява **текстов файл**.

- Съхранява информация (`std::string informationStored`);
- Реализира методите `ListContents()` и `copy()`.

---

### [25 т.] Клас `Folder`

Да се дефинира клас `Folder`, който наследява `Node` и представя **папка**, съдържаща списък от други елементи (`Node*`).

- Съдържа `std::vector<Node*> contents`;
- Метод `void add(Node* element)` — добавя нов елемент (чрез копиране!);
- Реализира методите `ListContents()` и `copy()` така, че да копира дълбоко съдържанието на папката;
- Деструкторът трябва да освобождава динамично заделената памет.

---

### [20 т.] Виртуално копиране

- Да се използват виртуални конструктори (метод `copy`) за коректно копиране на обекти с различен тип;
- Когато се добавя обект в папка (`add()`), да се създава **копие на обекта**, а не просто да се добавя оригиналът;
- Програмата трябва да работи с **указатели към базовия клас `Node`** и да създава копия чрез `copy()`.

---

### [15 т.] Демонстрация

Да се демонстрира работата на файловата система чрез `main()`, като се създаде следната структура:

```

Folder "Data"
├── TextDocument "Act"
├── Folder "Employees"
│ ├── TextDocument "Maria"
│ └── TextDocument "Ivanka"
├── Folder "Departments"
│ └── TextDocument "Manifacturing"

```

### Очаквано поведение

- Всички обекти се създават и копират правилно;
- Съдържанието се извежда чрез `ListContents()` в коректен ред;
- Паметта се освобождава при края на програмата и се извежда съобщение за всяко изтриване.

---

### Забележка

> ПРЕГЛЕДАЙТЕ КАКВО СА ВИРТУАЛНИ COPY КОНСТРУКТОРИ!

> При копиране на обекти да се използва **виртуален метод `copy()`**, а не `new` по тип на производния клас директно. Това е класически проблем за **виртуални конструктори**.
