# Lvalue, Rvalue и препратки (& и &&) в C++

В C++ всеки израз попада в една от основните категории: **lvalue** или **rvalue**. Разбирането на тези концепции е ключово за овладяване на **move семантиката**, **ефективното използване на ресурси** и **работата с препратки**.

---

## 1. Какво е Lvalue?

**Lvalue** (locator value) е израз, който **има адрес в паметта** и **може да бъде използван от лявата страна на операция за присвояване**.

Примери:

```cpp
int x = 10;     // x е lvalue
x = 20;         // валидно, защото x е отляво
int* p = &x;    // &x е валидно, x има адрес
```

---

## 2. Какво е Rvalue?

**Rvalue** е временна стойност, която **няма име и не може да бъде адресирана**. Използва се главно отдясно на операции за присвояване.

Примери:

```cpp
int y = 5 + 6;     // 5 + 6 е rvalue
int z = y * 2;     // y * 2 е rvalue
int* p = &(y + 1); // грешка – rvalue няма адрес
```

---

## 3. Разликата между стойност и адрес

- Всеки **lvalue има адрес** — можем да го реферираме с `&`.
- **Rvalue няма адрес**, не можем да вземем адреса му.

```cpp
int a = 10;
int* ptr = &a;     // OK

int* ptr2 = &(a + 1); // Error: (a + 1) е rvalue
```

---

## 4. Препратки – `&` и `&&`

### A. Lvalue препратка (`T&`)

Позволява ни да препращаме към **съществуващ обект** (lvalue):

```cpp
int x = 42;
int& ref = x; // OK – ref е lvalue препратка
```

Не може да реферира rvalue:

```cpp
int& ref = 10; // грешка: 10 е rvalue
```

---

### B. Rvalue препратка (`T&&`)

Въведена в C++11. Позволява ни да „уловим“ временен обект (rvalue):

```cpp
int&& ref = 10;     // OK
int&& ref2 = x + 5; // OK

int y = 20;
int&& ref3 = std::move(y); // std::move преобразува y в rvalue
```

---

## 5. std::move

### std::move

Функция, която **превръща Lvalue в Rvalue**, за да може да се използва с `T&&`.

```cpp
std::string a = "hello";
std::string b = std::move(a); // извиква move конструктор
```

След `std::move(a)` обектът `a` е **в невалидно, но дефинирано състояние** – не трябва да се използва освен за присвояване или унищожение.

---

## 6. Пример: move семантика с препратки

```cpp
#include <iostream>
#include <utility>

void byLvalueRef(int& x) {
    std::cout << "Lvalue reference\n";
}

void byRvalueRef(int&& x) {
    std::cout << "Rvalue reference\n";
}

int main() {
    int a = 5;
    byLvalueRef(a);          // извиква lvalue варианта
    byRvalueRef(10);         // извиква rvalue варианта
    byRvalueRef(std::move(a)); // извиква rvalue варианта
}
```

---

## 7. Обобщение

| Тип    | Има адрес | Променлив | Може да бъде аргумент на `T&` | Може да бъде аргумент на `T&&` |
| ------ | --------- | --------- | ----------------------------- | ------------------------------ |
| Lvalue | Да        | Да        | Да                            | Да (с `std::move`)             |
| Rvalue | Не        | Не        | Не                            | Да                             |

Разграничението между **стойност** и **адрес**, между **lvalue и rvalue**, както и разбирането на `&` и `&&`, са основата на ефективния и модерен C++ код.
