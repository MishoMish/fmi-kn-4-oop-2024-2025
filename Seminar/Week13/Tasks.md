# Задачи по Move семантика

## Задача 1: Структура от числа

Създайте клас `NumberArray`, който:

- Пази динамично заделен масив от цели числа (`int*`)
- Има:
  - Конструктор
  - Копиращ конструктор
  - Move конструктор
  - Копиращ оператор за присвояване
  - Move оператор за присвояване
  - Деструктор
- Предоставя метод `void print() const`, който отпечатва масива

Тествайте поведението с:

```cpp
NumberArray a(5);       // Създава масив от 5 елемента
NumberArray b = a;      // Копиране
NumberArray c = std::move(a); // Преместване
```

## Задача 2: Списък с имена (std::string)

Създайте клас `NameList`, който:

- Съдържа `std::vector<std::string>` като член-данна
- Има move конструктор и move оператор
- Забранява копиране с `= delete`
- Има метод `void addName(const std::string&)`
- Има метод `void print() const`

Тествайте със:

```cpp
NameList list1;
list1.addName("Ivan");
list1.addName("Maria");

NameList list2 = std::move(list1); // Преместване
list2.print(); // Очаква се да покаже имената
```

## Задача 3: Move-съвместим стек

Имплементирайте шаблонен клас `MoveStack<T>`, подобен на `std::stack`, който:

- Пази масив от `T` елементи
- Позволява само move операции
- Забранява копиране
- Има:
  - Метод `void push(T&& element)`
  - Метод `T pop()`
  - Метод `bool empty() const`

**Забележка:** Използвайте `std::unique_ptr<T[]>` за управление на динамичната памет.

## Задача 4 (Допълнителна): Профилиране на move/копиране

Създайте клас `Tracer`, който при извикване на копиращ/преместващ конструктор/оператор отпечатва съобщение. Използвайте този клас с `std::vector<Tracer>` и наблюдавайте какво се извиква при:

- `v.push_back(x);`
- `v.push_back(std::move(x));`
- `v.emplace_back();`
