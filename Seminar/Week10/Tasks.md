# Задачи за студенти – Полиморфизъм и Фабрики

## Задача 1: Говорещи животни

Създайте абстрактен базов клас `Animal`, съдържащ виртуален метод `speak()` и виртуален деструктор. Наследете от него следните класове:

- `Dog`
- `Cat`
- `Parrot`

Всеки от класовете трябва да имплементира `speak()`, като извежда подходящо съобщение в конзолата (например "Woof!", "Meow!", "I can talk!").

Създайте `std::vector<Animal*>`, добавете поне по един обект от всеки тип, и използвайте цикъл, за да извикате `speak()` за всеки.

> Подсказка: не забравяйте да освободите заделената памет с `delete` и да използвате виртуален деструктор.

---

## Задача 2: Фабрика за животни

Създайте клас `AnimalFactory`, съдържащ статичен метод:

```cpp
static Animal* createAnimal(const std::string& type);
```

Методът трябва да връща указател към `Dog`, `Cat` или `Parrot` в зависимост от подадения стринг. Ако типът е непознат, върнете `nullptr` или изведете съобщение за грешка.

Използвайте фабриката, за да създавате животни чрез въвеждане от потребителя. Например:

```
> Enter animal type:
> dog
> Woof!
```

---

## Задача 3: Животни с имена

Нека всеки животински клас има име. Добавете поле `std::string name` в класа `Animal` (или наследниците), и го задавайте при създаване на обекта.

Методът `speak()` трябва да използва името на животното:

```cpp
// Пример:
I'm Rex the dog!
```

Променете фабриката така, че да приема и име:

```cpp
static Animal* createAnimal(const std::string& type, const std::string& name);
```

---

## Задача 4: Животни от файл (десериализация)

Даден е текстов файл с животни, всеки ред е от вида:

```
dog Rex
cat Mimi
parrot Koko
```

Прочетете файла ред по ред, използвайте фабриката, за да създадете съответните обекти, и ги запазете във `std::vector<Animal*>`.

След това извикайте `speak()` на всички създадени животни.

---

## Задача 5: Подобрена фабрика с регистрация

Създайте подобрена фабрика, която позволява добавяне на нови типове животни по време на изпълнение. Използвайте map от стринг към функция:

```cpp
std::map<std::string, std::function<Animal*(const std::string&)>> registry;
```

Добавете метод `registerAnimal`, който записва нов тип в регистъра. Например:

```cpp
AnimalFactory::registerAnimal("dog", [](const std::string& name) { return new Dog(name); });
```

Методът `createAnimal` трябва да използва регистъра вместо if/else.

---

## Задача 6: Добавете Strategy поведение

Разширете животните с поведение, което може да се променя в runtime. Създайте интерфейс `SoundStrategy`, с метод `makeSound()`. Различни стратегии могат да бъдат:

- `LoudSound`
- `SoftSound`
- `NoSound`

Добавете поле от тип `SoundStrategy*` в `Animal`, и пренасочете `speak()` към стратегията. Позволете промяна на стратегията по време на изпълнение:

```cpp
animal->setSoundStrategy(new NoSound());
```

> Тази задача илюстрира използването на Strategy pattern с полиморфизъм и динамична композиция.

---

## Задача 7 (по избор): Singleton логгер за събития

Създайте клас `Logger`, който има единствена инстанция и се използва за записване на събития (напр. всяко `speak()`).

Всеки път когато животно "говори", се записва ред в лог:

```
[INFO] Rex the dog said: Woof!
```

Използвайте Singleton pattern, за да гарантирате, че има само един логгер.

---

## Задача 8 (по избор): Клониране на животни (Prototype)

Добавете метод `clone()` към `Animal`, който връща копие на обекта. Това може да бъде използвано за дублиране на животни без да се знае техният конкретен тип.

```cpp
Animal* original = new Dog("Rex");
Animal* copy = original->clone();
```

Тествайте клонирането и покажете, че новото животно има същото поведение и име.
