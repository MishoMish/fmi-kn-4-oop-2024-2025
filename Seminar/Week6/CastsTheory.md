# Типове каствания в C++

В C++ съществуват четири основни вида кастване:

1. `static_cast`
2. `dynamic_cast`
3. `reinterpret_cast`
4. `const_cast`

## 1. `static_cast`

`static_cast` се използва за преобразуване на типове, които са свързани и могат да бъдат конвертирани по време на компилация.

### Основни характеристики:

- Използва се за преобразуване между вградени типове (напр. `int` към `double`).
- Може да преобразува указатели между класове в една и съща йерархия, но не проверява валидността по време на изпълнение.
- Не може да се използва за преобразуване на несъвместими типове като указател в цяло число.

### Пример:

```cpp
#include <iostream>
class Base { public: virtual void show() {} };
class Derived : public Base { public: void show() { std::cout << "Derived"; } };

int main() {
    double a = 3.14;
    int b = static_cast<int>(a); // Конвертира double в int
    std::cout << b << std::endl;

    Base* basePtr = new Derived();
    Derived* derivedPtr = static_cast<Derived*>(basePtr); // Работи, но няма проверка на типа
    derivedPtr->show();
    delete basePtr;
}
```

## 2. `dynamic_cast`

`dynamic_cast` се използва за безопасно преобразуване на указатели в полиморфна йерархия по време на изпълнение.

### Основни характеристики:

- Работи само с полиморфни класове (класове с поне една виртуална функция).
- Проверява валидността на преобразуването по време на изпълнение.
- Ако преобразуването е неуспешно, връща `nullptr` за указатели или хвърля `std::bad_cast` за референции.

### Пример:

```cpp
#include <iostream>
class Base { public: virtual ~Base() {} };
class Derived : public Base { public: void show() { std::cout << "Derived"; } };

int main() {
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
    if (derivedPtr) {
        derivedPtr->show();
    } else {
        std::cout << "Преобразуването неуспешно!";
    }
    delete basePtr;
}
```

## 3. `reinterpret_cast`

`reinterpret_cast` се използва за преобразуване на несъвместими типове указатели и обекти. Позволява интерпретация на един тип като друг без проверка на съвместимостта.

### Основни характеристики:

- Може да преобразува указатели към различни несъвместими типове.
- Използва се при работа с ниско ниво на паметта (напр. при работа с двоични файлове или хардуер).
- Може да доведе до неопределено поведение, ако се използва неправилно.

### Пример:

```cpp
#include <iostream>
struct Data {
    int x;
    double y;
};

int main() {
    Data d = {42, 3.14};
    char* rawData = reinterpret_cast<char*>(&d);
    for (size_t i = 0; i < sizeof(d); i++) {
        std::cout << std::hex << static_cast<int>(rawData[i]) << " ";
    }
    std::cout << std::endl;
}
```

## 4. `const_cast`

`const_cast` се използва за премахване или добавяне на `const` модификатора на променливи.

### Основни характеристики:

- Позволява премахване на `const` от указатели и референции.
- Ако се използва неправилно (напр. промяна на `const` данни), може да доведе до неопределено поведение.

### Пример:

```cpp
#include <iostream>
void print(const int& x) {
    int& y = const_cast<int&>(x);
    y = 100; // Променяме стойността, въпреки че параметърът е const
    std::cout << "Новата стойност: " << y << std::endl;
}

int main() {
    int a = 5;
    print(a);
    std::cout << "Оригиналната стойност: " << a << std::endl;
}
```

## Заключение

Всеки от тези видове каствания има своето предназначение:

- **`static_cast`** – за преобразуване на съвместими типове по време на компилация.
- **`dynamic_cast`** – за безопасно преобразуване на полиморфни обекти по време на изпълнение.
- **`reinterpret_cast`** – за нискониво преобразуване между несъвместими типове.
- **`const_cast`** – за премахване/добавяне на `const` модификатор.

Използването на правилния вид кастване е важно за писане на надежден и четим код.
