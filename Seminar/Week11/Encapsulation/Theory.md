## Видове наследяване в C++

В C++ имаме три вида наследяване, които се определят от спецификатора за достъп, използван при деклариране на наследяването:

### 1. public наследяване

При public наследяване:

- Публичните членове на базовия клас остават публични в производния клас
- Защитените членове на базовия клас остават защитени в производния клас
- Частните членове на базовия клас не са директно достъпни в производния клас

Това е най-често използваният вид наследяване и изразява отношение "е" (is-a): Производният клас е специализация на базовия клас.

```cpp
class Animal
{
public:
    void breathe() { std::cout << "Дишам!\n"; }

protected:
    void sleep() { std::cout << "Спя!\n"; }

private:
    void think() { std::cout << "Мисля!\n"; }
};

// Публично наследяване - "Котката е животно"
class Cat : public Animal
{
public:
    void meow() { std::cout << "Мяу!\n"; }

    void demonstrate()
    {
        breathe();  // OK - public член остава public в Cat
        sleep();    // OK - protected член остава protected в Cat
        // think(); // Грешка - private член не е достъпен в Cat
    }
};

int main()
{
    Cat cat;
    cat.breathe();  // OK - public член е достъпен извън класа
    // cat.sleep(); // Грешка - protected член не е достъпен извън йерархията на класа
    return 0;
}
```

### 2. protected наследяване

При protected наследяване:

- Публичните и защитените членове на базовия клас стават защитени в производния клас
- Частните членове на базовия клас не са директно достъпни в производния клас

Това изразява отношение "имплементирано чрез" (implemented-in-terms-of), но позволява на бъдещи подкласове да имат достъп до наследените членове.

```cpp
class Engine
{
public:
    void start() { std::cout << "Двигателят стартира!\n"; }
};

// Protected наследяване
class Car : protected Engine
{
public:
    void drive()
    {
        start();  // OK - наследеният public член е protected в Car
        std::cout << "Автомобилът се движи!\n";
    }
};

class SportsCar : public Car
{
public:
    void race()
    {
        start();  // OK - наследеният protected член е достъпен в наследниците
        std::cout << "Състезателният автомобил ускорява!\n";
    }
};

int main()
{
    Car car;
    // car.start(); // Грешка - методът start() е protected в Car
    car.drive();    // OK

    SportsCar sportsCar;
    // sportsCar.start(); // Грешка - методът start() е protected в SportsCar
    sportsCar.drive();    // OK
    sportsCar.race();     // OK

    return 0;
}
```

### 3. private наследяване

При private наследяване:

- Публичните и защитените членове на базовия клас стават частни в производния клас
- Частните членове на базовия клас не са директно достъпни в производния клас

Това изразява отношение "имплементирано чрез" (implemented-in-terms-of), но НЕ позволява на бъдещи подкласове да имат достъп до наследените членове.

```cpp
class Logger
{
public:
    void log(const std::string& message) { std::cout << "Лог: " << message << '\n'; }
};

// Private наследяване - "FileManager е имплементиран чрез Logger"
class FileManager : private Logger
{
public:
    void writeFile(const std::string& filename, const std::string& content)
    {
        log("Записване във файл: " + filename);  // OK - наследеният метод е private в FileManager
        std::cout << "Записване на съдържание във файл " << filename << '\n';
    }
};

class AdvancedFileManager : public FileManager
{
public:
    void compressFile(const std::string& filename)
    {
        // log("Компресиране на файл: " + filename); // Грешка - log() не е достъпен
        std::cout << "Компресиране на файл " << filename << '\n';
    }
};

int main()
{
    FileManager manager;
    // manager.log("Тест"); // Грешка - log() e private в FileManager
    manager.writeFile("data.txt", "Съдържание");

    return 0;
}
```

### Кога да използваме различните видове наследяване?

1. **public наследяване** - Когато производният клас е специализация на базовия клас (IS-A отношение):

   - `Student` е `Person`
   - `Circle` е `Shape`
   - `Cat` е `Animal`

2. **protected наследяване** - Рядко използвано. Когато искаме да използваме функционалността на базовия клас, но да не я излагаме на външния свят, като същевременно я правим достъпна за подкласовете.

3. **private наследяване** - Когато искаме да използваме функционалността на базовия клас, но да не я излагаме на външния свят или на подкласовете:
   - Алтернатива на композицията (has-a отношение)
   - Когато искаме да преопределим virtual функции от базовия клас
   - Когато имаме нужда от достъп до protected членове на базовия клас

### Важно за запомняне

- **По подразбиране**, ако не укажем спецификатор при наследяване, C++ използва:
  - `private` наследяване за `class`
  - `public` наследяване за `struct`

````cpp
class Base {};

class Derived1 : Base {};           // По подразбиране private наследяване
class Derived2 : private Base {};   // Еквивалентно на горното
class Derived3 : public Base {};    // Публично наследяване

struct DerivedStruct : Base {};     // По подразбиране public наследяване
```# Ползите от скриването на данни (енкапсулация)

В обектно-ориентираното програмиране, **скриването на данни** (наричано още **енкапсулация**) е принцип, който ограничава директния достъп до някои компоненти на обекта, като скрива детайлите за имплементацията и предоставя само необходимия интерфейс.

## Какво е скриване на данни?

Скриването на данни е концепция, при която данните на класа се скриват от външния свят и са достъпни само чрез методи на същия клас. Това означава, че класът поддържа своето вътрешно състояние като **частно (private)**, като предоставя **публични (public)** методи за взаимодействие с това състояние.

## Примерен проблем без скриване на данни

Нека разгледаме пример. Представете си, че имаме програма, която трябва да управлява данни за служители:

```cpp
struct Employee
{
    std::string m_name;
    int m_id;
    double m_wage;
};

int main()
{
    Employee alex { "Alex", 1, 25.00 };
    Employee joe { "Joe", 2, 22.25 };

    // Директно модифициране на данни
    alex.m_wage = 26.00;
    joe.m_wage = 23.25;

    return 0;
}
````

В този пример всички членове на данни са публични и достъпни отвсякъде. Това създава потенциални проблеми:

1. **Липса на валидация**: Потребителят може да зададе невалидни стойности (например отрицателна заплата).
2. **Нарушаване на вътрешната логика**: Данните могат да бъдат променени по начин, който нарушава бизнес-логиката.
3. **Трудна поддръжка**: Ако променим начина на съхранение на данните, това ще изисква промени в целия код, който работи директно с тези данни.

## Енкапсулация: решението

Енкапсулацията решава тези проблеми, като:

1. Скрива вътрешните данни като `private`
2. Предоставя публични функции за достъп и модификация (getters и setters)
3. Добавя валидация в методите за модификация

## Спецификатори за достъп в C++: private, protected и public

В C++ имаме три основни спецификатора за достъп, които контролират видимостта на членовете на класа:

### 1. private

- Членовете са достъпни само в рамките на самия клас
- По подразбиране, членовете на `class` са `private`
- Осигурява най-високо ниво на енкапсулация
- Нито подкласовете, нито външните класове имат достъп до тези членове

### 2. protected

- Членовете са достъпни в рамките на класа и в неговите производни класове (подкласове)
- Позволява подкласовете да имат достъп до тези членове, но ги скрива от външния свят
- Полезно за създаване на йерархия от класове, където определени функционалности трябва да бъдат споделени между базовия клас и неговите наследници

### 3. public

- Членовете са достъпни от всеки код, който има достъп до обекта
- По подразбиране, членовете на `struct` са `public`
- Обикновено използвано за интерфейса на класа (методи, които трябва да са достъпни от потребителите)

### Пример за използване на различни спецификатори за достъп:

```cpp
class Person
{
private:
    std::string m_password;  // Само този клас има достъп

protected:
    std::string m_name;      // Този клас и наследниците имат достъп
    int m_age;

public:
    Person(const std::string& name, int age, const std::string& password)
        : m_name{name}, m_age{age}, m_password{password}
    {
    }

    void printInfo() const   // Всеки има достъп до тази функция
    {
        std::cout << "Име: " << m_name << ", Възраст: " << m_age << '\n';
    }

    bool validatePassword(const std::string& attempt) const
    {
        return m_password == attempt;
    }
};

class Student : public Person
{
private:
    double m_gpa;  // Само този клас има достъп

public:
    Student(const std::string& name, int age, const std::string& password, double gpa)
        : Person(name, age, password), m_gpa{gpa}
    {
    }

    void printStudentInfo() const
    {
        // Имаме достъп до m_name и m_age, защото са protected
        std::cout << "Студент: " << m_name << ", Възраст: " << m_age
                  << ", Среден успех: " << m_gpa << '\n';

        // Нямаме достъп до m_password, защото е private в базовия клас
        // std::cout << m_password; // Това ще доведе до грешка при компилация
    }
};
```

```cpp
class Employee
{
private:
    std::string m_name;
    int m_id;
    double m_wage;

public:
    Employee(std::string name, int id, double wage)
        : m_name{name}, m_id{id}, m_wage{wage}
    {
    }

    // Getter за име
    const std::string& getName() const { return m_name; }

    // Getter за ID
    int getID() const { return m_id; }

    // Getter за заплата
    double getWage() const { return m_wage; }

    // Setter за заплата с валидация
    void setWage(double wage)
    {
        // Валидация: не позволяваме отрицателна заплата
        if (wage >= 0.0)
            m_wage = wage;
        else
            std::cerr << "Грешка: Заплатата не може да бъде отрицателна\n";
    }
};
```

## Ползи от енкапсулацията

### 1. Контрол на достъпа до данни

Класът може да контролира как и дали външният код може да манипулира вътрешните му данни. Например, можем да направим стойността на ID само за четене, като не предоставим setter метод за нея.

### 2. Валидация на входните данни

Методите setters могат да извършват проверки преди да променят данните:

```cpp
void setWage(double wage)
{
    // Валидация: не позволяваме отрицателна заплата
    if (wage >= 0.0)
        m_wage = wage;
    else
        std::cerr << "Грешка: Заплатата не може да бъде отрицателна\n";
}
```

### 3. Поддръжка на инварианти на класа

#### Какво е инвариант?

**Инвариант** е условие или свойство, което остава непроменено (запазва се) при определена операция или трансформация. В програмирането, инвариантите се използват за осигуряване на правилното функциониране на алгоритми и структури от данни.

#### Инварианти в обектно-ориентираното програмиране

В контекста на класовете и обектите, **инвариант на класа** е условие, което трябва да бъде валидно през целия живот на обекта, преди и след изпълнението на публичните методи. Инвариантите на класа са едни от най-важните инструменти за осигуряване на валидност на данните и коректност на програмата.

Примери за инварианти на класа могат да бъдат:

- Банкова сметка никога не може да има отрицателен баланс (ако не е разрешен овърдрафт)
- Годината на раждане на човек трябва да бъде преди настоящата година
- Точка от окръжност винаги трябва да бъде на фиксирано разстояние от центъра

Енкапсулацията позволява да поддържаме такива инварианти, като контролираме достъпа до данните:

```cpp
class BankAccount
{
private:
    std::string m_accountNumber;
    double m_balance;

public:
    BankAccount(const std::string& accountNumber, double initialBalance)
        : m_accountNumber{accountNumber}
    {
        // Проверка на инварианта при създаване на обекта
        if (initialBalance < 0.0)
            throw std::invalid_argument("Началният баланс не може да бъде отрицателен");
        m_balance = initialBalance;
    }

    void deposit(double amount)
    {
        // Проверка за валидна сума
        if (amount <= 0.0)
            throw std::invalid_argument("Сумата за депозит трябва да бъде положителна");
        m_balance += amount;
        // Инвариантът се запазва: балансът е неотрицателен
    }

    void withdraw(double amount)
    {
        // Проверки, които поддържат инварианта
        if (amount <= 0.0)
            throw std::invalid_argument("Сумата за теглене трябва да бъде положителна");
        if (amount > m_balance)
            throw std::invalid_argument("Недостатъчен баланс");

        m_balance -= amount;
        // Инвариантът се запазва: балансът е неотрицателен
    }

    double getBalance() const
    {
        return m_balance;
    }
};
```

#### Инварианти на цикъла в алгоритмите

Концепцията за инварианти е ключова не само за класове, но и за алгоритми. **Инвариант на цикъла** е условие, което остава вярно при всяко изпълнение на цикъла.

Според учебника по Дизайн и Анализ на Алгоритми на Минко Марков:

> "Доказателствата за коректност с инвариант на цикъла по същество също са доказателства по индукция, но с индукцията не е по големината на входа, а по броя на 'завъртанията' на цикъла. Инвариантът е едноместен предикат, свързан с цикъла. Променливата на предиката е броят на достиганията на дадена инструкция на алгоритъма. По правило, тази инструкция е инструкцията, която съдържа условието за край на цикъла.
>
> Да кажем, че условието за край на цикъла е на ред `. Въпросният предикат трябва да е:
• верен първия път, когато изпълнението на алгоритъма е на ред `,
> • верността му трябва да се запазва по време на всяко изпълнение, откъдето идва и името 'инвариант', и
> • в момента на напускане на цикъла (такъв момент настъпва неизбежно, щом алгоритъмът завършва) неговата вярност трябва да влече директно това, което искаме да докажем за алгоритъма."

#### Пример за инвариант на цикъла:

Нека разгледаме алгоритъма `Max_Unsorted_iter` от курса по ДАА на Минко Марков:

```
Max_Unsorted_iter(A[1...n]: array of integers)
1  max ← -∞
2  i ← 1
3  while i ≤ n do
4    if A[i] > max
5      max ← A[i]
6    i ← i + 1
7  return max
```

Инвариантът на този алгоритъм е:

> "Всеки път, когато изпълнението на Max_Unsorted_iter е на ред 3, променливата max съдържа стойността на максималния елемент в подмасива A[1..i-1]."

Нека проверим дали този инвариант е верен:

1. **Първо изпълнение на ред 3**:

   - i = 1, следователно подмасивът A[1..i-1] е A[1..0], който е празен
   - max = -∞, което е "максимумът" на празен масив (по определение)
   - Следователно инвариантът е верен при първото достигане

2. **Запазва се ли истинността на предиката при всяко изпълнение?**:

   - Ако A[i] > max, тогава max става A[i]
   - Ако A[i] ≤ max, тогава max остава непроменен
   - i се увеличава с 1
   - При следващото изпълнение на ред 3, max ще съдържа максималния елемент от A[1..i-1]
   - Следователно инвариантът се запазва

3. **При напускане на цикъла**:
   - Когато i > n, цикълът приключва
   - Инвариантът гарантира, че max съдържа максималния елемент от A[1..i-1]
   - Но i > n, което означава i-1 ≥ n, следователно подмасивът A[1..i-1] включва всички елементи A[1..n]
   - Следователно max е максималният елемент от целия масив

Този пример показва как инвариантите могат да бъдат използвани за доказване на коректността на алгоритмите.

#### Връзка между инвариантите на класа и енкапсулацията

Енкапсулацията е механизмът, който позволява поддържането на инварианти на класа:

1. **Контрол на достъпа**: Чрез скриване на данните и предоставяне на контролиран интерфейс, можем да гарантираме, че инвариантите няма да бъдат нарушени.

2. **Валидация при конструиране**: Конструкторите трябва да установят инвариантите.

3. **Запазване при операции**: Всеки метод, който модифицира състоянието, трябва да запази инвариантите.

Без енкапсулация не бихме могли да контролираме как се модифицират данните, което би направило невъзможно поддържането на инварианти.

### 4. Абстракция на имплементацията

Потребителите на класа не трябва да знаят как работи имплементацията - те просто използват публичния интерфейс. Това се нарича "принцип на най-малкото знание" или "закон на Деметра".

### 5. Гъвкавост и лесно обновяване

Можем да променяме вътрешната имплементация на класа, без да засягаме кода, който го използва:

```cpp
class Employee
{
private:
    std::string m_name;
    int m_id;

    // Променяме как съхраняваме заплатата - от double към годишна заплата в цели числа
    int m_annualSalary;

public:
    Employee(std::string name, int id, double hourlyWage)
        : m_name{name}, m_id{id}, m_annualSalary{static_cast<int>(hourlyWage * 40 * 52)}
    {
    }

    // Интерфейсът остава същият, въпреки че имплементацията е различна
    double getWage() const { return m_annualSalary / (40.0 * 52); }

    void setWage(double hourlyWage)
    {
        if (hourlyWage >= 0.0)
            m_annualSalary = static_cast<int>(hourlyWage * 40 * 52);
        else
            std::cerr << "Грешка: Заплатата не може да бъде отрицателна\n";
    }
};
```

### 6. Промяна на отговорите спрямо състоянието

Можем да правим методите да връщат различни резултати, базирани на вътрешното състояние на обекта.

### 7. Мързеливо оценяване и кеширане

Можем да отложим пресмятанията до момента, в който те са необходими, или да кешираме резултати:

```cpp
class MathValues
{
private:
    int m_value;
    mutable bool m_calculated { false };
    mutable double m_sqrtValue;

public:
    MathValues(int value) : m_value{value} {}

    double getSqrt() const
    {
        if (!m_calculated)
        {
            m_sqrtValue = std::sqrt(m_value);
            m_calculated = true; // Кешираме резултата
        }

        return m_sqrtValue;
    }

    void setValue(int value)
    {
        if (value != m_value)
        {
            m_value = value;
            m_calculated = false; // Маркираме, че резултатът трябва да се преизчисли
        }
    }
};
```

### 8. Поддръжка на неявни операции

Класът може да извършва операции, които не са очевидни за потребителя:

```cpp
class DatabaseConnection
{
private:
    bool m_connected { false };
    std::string m_connectionString;

    void ensureConnected()
    {
        if (!m_connected)
        {
            // Свързване с базата данни
            m_connected = true;
        }
    }

public:
    DatabaseConnection(const std::string& connectionString)
        : m_connectionString{connectionString}
    {
    }

    // Автоматично се свързваме, когато е необходимо
    bool executeQuery(const std::string& query)
    {
        ensureConnected(); // Неявно се свързваме, ако не сме свързани

        // Изпълняваме заявката
        return true;
    }
};
```

## Заключение

Енкапсулацията е един от основните принципи на обектно-ориентираното програмиране, заедно с наследяването и полиморфизма. Тя позволява:

1. Да скрием имплементацията и да покажем само интерфейса
2. Да контролираме достъпа до данните на класа
3. Да валидираме входните данни
4. Да променяме имплементацията без да засягаме използващия код
5. Да поддържаме по-лесно кода и да намалим грешките

В C++, енкапсулацията се постига чрез специфициране на нивата на достъп `private`, `protected` и `public` и чрез създаване на подходящи методи за достъп и модификация на данните.
